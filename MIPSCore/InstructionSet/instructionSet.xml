<!-- Use this xml file to add instructions -->
<!--  Explanation:
        
        name:           the friendly user name of the instruction 
        assembler:      the assembler macro of the instruction
        meaning:        the meaning of the instruction
        
        format:         the instruction format
                        R...Instruction format R (only register operands)
                        I...Instruction format I (immediate)
                        J...Instruction format J (jump)
                        
        opcode:         the opcode of the instruction (UInt)
        function:       the function code of the instruction (UInt)
        
        regWrite:       declares if a value has to be written to a register in the registerfile
                        true...specified register in the registerfile gets overwritten (rd = rs + rt => rd gets overwritten)
                        false...no register in the registerfile gets overwritten
                        
        regDestination: which register in the register file needs to be overwritten 
                        (regWrite needs to be true to overwrite a register in the registerfile)
                        rt...specified rt register gets overwritten
                        rd...specified rd register gets overwritten
                        ra...specified ra register gets overwritten
                        
        regFileInput:   from where the comes the value which overrides the register in the registerfile
                        (regWrite needs to be true to overwrite a register in the registerfile)
                        aluLO...overwrite the register value with the alu low register
                        aluHI...overwrite the register value with the alu high register
                        dataMemory...overwrite the register value with the value from the data memory
                        programCounter...overwrite the register value with the value of the program counter (rd = pc + 4)
                        
       aluSource:       from where the alu should the value to calculate the result
                        regFile...take the values from the register file (rd = rs + rt => alu takes the rs and rt register to calculate the value)
                        signExtend...take the value from register and signExtender (rt = rs + imm. => alu takes rs and imm. to calculate the value)
                        
       aluControl:      which action the alu should perform
                        and...simple and
                        or...simple or
                        xor...exlusive or
                        add...addition
                        addu...addition unsigned
                        sub...subtraction
                        setLessThan...set on less than
                        setLessThanU...set on less than unsigned
                        setLessThanZero...set on less than zero
                        mult...multiply
                        div...divide
                        shiftLeft...shift left
                        shiftRight...shift right
                        shiftLeft16...shift immediate 16 bits left
                        nor...not or
                        stall...stall the alu => no action performed
                        
      memWrite:         true if we need to write to the data memory
      
      memRead:          true if we need to read from the data memory
      
      memWordSize:      how much data we need to read/write from the data memory
                        singleByte...one byte
                        halfWord...half word
                        word...word
      
      pcSource:         from where should the program counter take the next value
                        programCounter...take the value from the program counter (pc = pc + 4)
                        signExtendEqual...take the value from the sign extender, but only if the zero flag of the alu is set (pc += imm. * 4 + 4 else pc += 4)
                        signExtendUnequal...take the value from the sign extender, but only if the zero flag of the alu is not set (pc += imm. * 4 + 4 else pc += 4)
                        signExtendLessThanZero...take the value from the sign extender, if aluLO result is 1 (pc += imm. * 4 + 4 else pc += 4)
                        signExtendLessOrEqualZero...take the value form the sing extender, but only if the zero flag of the alu is not set or the alu result is 1 (pc += imm. * 4 + 4 else pc += 4)
                        jump...take the value from the jumpTarget(24 bit) (pc = jumpTarget * 4)
                        register...take the value from the rs register (pc = rs)
    
    systemcall:         true if the instruction is a systemcall
    -->

<CInstructionSet>

  <!-- R INSTRUCTIONS -->
  <CInstruction>
    <name>shift left logical</name>
    <assembler>sll</assembler>
    <example>sll rd, rt, shamt</example>
    <meaning>rd = rt&lt;&lt;shamt</meaning>
    <format>R</format>
    <opcode>0</opcode>
    <function>0</function>
    <regWrite>true</regWrite>
    <regDestination>rd</regDestination>
    <regFileInput>aluLO</regFileInput>
    <aluSource>regFile</aluSource>
    <aluControl>shiftLeft</aluControl>
    <memWrite>false</memWrite>
    <memRead>false</memRead>
    <memWordSize>singleByte</memWordSize>
    <pcSource>programCounter</pcSource>
    <systemcall>false</systemcall>
  </CInstruction>

  <CInstruction>
    <name>shift right logical</name>
    <assembler>srl</assembler>
    <example>srl rd, rt, shamt</example>
    <meaning>rd = rt&gt;&gt;shamt</meaning>
    <format>R</format>
    <opcode>0</opcode>
    <function>2</function>
    <regWrite>true</regWrite>
    <regDestination>rd</regDestination>
    <regFileInput>aluLO</regFileInput>
    <aluSource>regFile</aluSource>
    <aluControl>shiftRight</aluControl>
    <memWrite>false</memWrite>
    <memRead>false</memRead>
    <memWordSize>singleByte</memWordSize>
    <pcSource>programCounter</pcSource>
    <systemcall>false</systemcall>
  </CInstruction>

  <CInstruction>
    <name>jump register</name>
    <assembler>jr</assembler>
    <example>jr register</example>
    <meaning>pc = register</meaning>
    <format>R</format>
    <opcode>0</opcode>
    <function>8</function>
    <regWrite>false</regWrite>
    <regDestination>rd</regDestination>
    <regFileInput>aluLO</regFileInput>
    <aluSource>regFile</aluSource>
    <aluControl>stall</aluControl>
    <memWrite>false</memWrite>
    <memRead>false</memRead>
    <memWordSize>singleByte</memWordSize>
    <pcSource>register</pcSource>
    <systemcall>false</systemcall>
  </CInstruction>

  <CInstruction>
    <name>sytemcall</name>
    <assembler>syscall</assembler>
    <example></example>
    <meaning></meaning>
    <format>R</format>
    <opcode>0</opcode>
    <function>12</function>
    <regWrite>false</regWrite>
    <regDestination>rd</regDestination>
    <regFileInput>aluLO</regFileInput>
    <aluSource>regFile</aluSource>
    <aluControl>stall</aluControl>
    <memWrite>false</memWrite>
    <memRead>false</memRead>
    <memWordSize>singleByte</memWordSize>
    <pcSource>programCounter</pcSource>
    <systemcall>true</systemcall>
  </CInstruction>

  <CInstruction>
    <name>move from alu high register</name>
    <assembler>mfhi</assembler>
    <example>mfhi register</example>
    <meaning>rd = aluHI</meaning>
    <format>R</format>
    <opcode>0</opcode>
    <function>16</function>
    <regWrite>true</regWrite>
    <regDestination>rd</regDestination>
    <regFileInput>aluHI</regFileInput>
    <aluSource>regFile</aluSource>
    <aluControl>stall</aluControl>
    <memWrite>false</memWrite>
    <memRead>false</memRead>
    <memWordSize>singleByte</memWordSize>
    <pcSource>programCounter</pcSource>
    <systemcall>false</systemcall>
  </CInstruction>

  <CInstruction>
    <name>move from alu low register</name>
    <assembler>mflo</assembler>
    <example>mflo register</example>
    <meaning>rd = aluLO</meaning>
    <format>R</format>
    <opcode>0</opcode>
    <function>18</function>
    <regWrite>true</regWrite>
    <regDestination>rd</regDestination>
    <regFileInput>aluLO</regFileInput>
    <aluSource>regFile</aluSource>
    <aluControl>stall</aluControl>
    <memWrite>false</memWrite>
    <memRead>false</memRead>
    <memWordSize>singleByte</memWordSize>
    <pcSource>programCounter</pcSource>
    <systemcall>false</systemcall>
  </CInstruction>

  <CInstruction>
    <name>multiply</name>
    <assembler>mult</assembler>
    <example>mult rd, rs, rt</example>
    <meaning>rd = rs * rt</meaning>
    <format>R</format>
    <opcode>0</opcode>
    <function>24</function>
    <regWrite>true</regWrite>
    <regDestination>rd</regDestination>
    <regFileInput>aluLO</regFileInput>
    <aluSource>regFile</aluSource>
    <aluControl>mult</aluControl>
    <memWrite>false</memWrite>
    <memRead>false</memRead>
    <memWordSize>singleByte</memWordSize>
    <pcSource>programCounter</pcSource>
    <systemcall>false</systemcall>
  </CInstruction>

  <CInstruction>
    <name>multiply unsigned</name>
    <assembler>multu</assembler>
    <example>multu rd, rs, rt</example>
    <meaning>rd = rs * rt</meaning>
    <format>R</format>
    <opcode>0</opcode>
    <function>25</function>
    <regWrite>true</regWrite>
    <regDestination>rd</regDestination>
    <regFileInput>aluLO</regFileInput>
    <aluSource>regFile</aluSource>
    <aluControl>multu</aluControl>
    <memWrite>false</memWrite>
    <memRead>false</memRead>
    <memWordSize>singleByte</memWordSize>
    <pcSource>programCounter</pcSource>
    <systemcall>false</systemcall>
  </CInstruction>
  
  <CInstruction>
    <name>addition</name>
    <assembler>add</assembler>
    <example>add rd, rs, rt</example>
    <meaning>rd = rs + rt</meaning>
    <format>R</format>
    <opcode>0</opcode>
    <function>32</function>
    <regWrite>true</regWrite>
    <regDestination>rd</regDestination>
    <regFileInput>aluLO</regFileInput>
    <aluSource>regFile</aluSource>
    <aluControl>add</aluControl>
    <memWrite>false</memWrite>
    <memRead>false</memRead>
    <memWordSize>singleByte</memWordSize>
    <pcSource>programCounter</pcSource>
    <systemcall>false</systemcall>
  </CInstruction>

  <CInstruction>
    <name>addition unsigned</name>
    <assembler>addu</assembler>
    <example>addu rd, rs, rt</example>
    <meaning>rd = rs + rt</meaning>
    <format>R</format>
    <opcode>0</opcode>
    <function>33</function>
    <regWrite>true</regWrite>
    <regDestination>rd</regDestination>
    <regFileInput>aluLO</regFileInput>
    <aluSource>regFile</aluSource>
    <aluControl>addu</aluControl>
    <memWrite>false</memWrite>
    <memRead>false</memRead>
    <memWordSize>singleByte</memWordSize>
    <pcSource>programCounter</pcSource>
    <systemcall>false</systemcall>
  </CInstruction>

  <CInstruction>
    <name>subtraction</name>
    <assembler>sub</assembler>
    <example>sub rd, rs, rt</example>
    <meaning>rd = rs - rt</meaning>
    <format>R</format>
    <opcode>0</opcode>
    <function>34</function>
    <regWrite>true</regWrite>
    <regDestination>rd</regDestination>
    <regFileInput>aluLO</regFileInput>
    <aluSource>regFile</aluSource>
    <aluControl>sub</aluControl>
    <memWrite>false</memWrite>
    <memRead>false</memRead>
    <memWordSize>singleByte</memWordSize>
    <pcSource>programCounter</pcSource>
    <systemcall>false</systemcall>
  </CInstruction>

  <CInstruction>
    <name>subtraction unsigned</name>
    <assembler>subu</assembler>
    <example>subu rd, rs, rt</example>
    <meaning>rd = rs - rt</meaning>
    <format>R</format>
    <opcode>0</opcode>
    <function>35</function>
    <regWrite>true</regWrite>
    <regDestination>rd</regDestination>
    <regFileInput>aluLO</regFileInput>
    <aluSource>regFile</aluSource>
    <aluControl>subu</aluControl>
    <memWrite>false</memWrite>
    <memRead>false</memRead>
    <memWordSize>singleByte</memWordSize>
    <pcSource>programCounter</pcSource>
    <systemcall>false</systemcall>
  </CInstruction>

  <CInstruction>
    <name>and</name>
    <assembler>and</assembler>
    <example>and rd, rs, rt</example>
    <meaning>rd = rs and rt</meaning>
    <format>R</format>
    <opcode>0</opcode>
    <function>36</function>
    <regWrite>true</regWrite>
    <regDestination>rd</regDestination>
    <regFileInput>aluLO</regFileInput>
    <aluSource>regFile</aluSource>
    <aluControl>and</aluControl>
    <memWrite>false</memWrite>
    <memRead>false</memRead>
    <memWordSize>singleByte</memWordSize>
    <pcSource>programCounter</pcSource>
    <systemcall>false</systemcall>
  </CInstruction>

  <CInstruction>
    <name>or</name>
    <assembler>or</assembler>
    <example>or rd, rs, rt</example>
    <meaning>rd = rs or rt</meaning>
    <format>R</format>
    <opcode>0</opcode>
    <function>37</function>
    <regWrite>true</regWrite>
    <regDestination>rd</regDestination>
    <regFileInput>aluLO</regFileInput>
    <aluSource>regFile</aluSource>
    <aluControl>or</aluControl>
    <memWrite>false</memWrite>
    <memRead>false</memRead>
    <memWordSize>singleByte</memWordSize>
    <pcSource>programCounter</pcSource>
    <systemcall>false</systemcall>
  </CInstruction>

  <CInstruction>
    <name>exclusice or</name>
    <assembler>xor</assembler>
    <example>xor rd, rs, rt</example>
    <meaning>rd = rs xor rt</meaning>
    <format>R</format>
    <opcode>0</opcode>
    <function>38</function>
    <regWrite>true</regWrite>
    <regDestination>rd</regDestination>
    <regFileInput>aluLO</regFileInput>
    <aluSource>regFile</aluSource>
    <aluControl>xor</aluControl>
    <memWrite>false</memWrite>
    <memRead>false</memRead>
    <memWordSize>singleByte</memWordSize>
    <pcSource>programCounter</pcSource>
    <systemcall>false</systemcall>
  </CInstruction>

  <CInstruction>
    <name>not or</name>
    <assembler>nor</assembler>
    <example>nor rd, rs, rt</example>
    <meaning>rd = rs nor rt</meaning>
    <format>R</format>
    <opcode>0</opcode>
    <function>39</function>
    <regWrite>true</regWrite>
    <regDestination>rd</regDestination>
    <regFileInput>aluLO</regFileInput>
    <aluSource>regFile</aluSource>
    <aluControl>nor</aluControl>
    <memWrite>false</memWrite>
    <memRead>false</memRead>
    <memWordSize>singleByte</memWordSize>
    <pcSource>programCounter</pcSource>
    <systemcall>false</systemcall>
  </CInstruction>

  <CInstruction>
    <name>set less than</name>
    <assembler>slt</assembler>
    <example>slt rd, rs, rt</example>
    <meaning>if rs&lt;rt: rd=1 else= rd=0</meaning>
    <format>R</format>
    <opcode>0</opcode>
    <function>42</function>
    <regWrite>true</regWrite>
    <regDestination>rd</regDestination>
    <regFileInput>aluLO</regFileInput>
    <aluSource>regFile</aluSource>
    <aluControl>setLessThan</aluControl>
    <memWrite>false</memWrite>
    <memRead>false</memRead>
    <memWordSize>singleByte</memWordSize>
    <pcSource>programCounter</pcSource>
    <systemcall>false</systemcall>
  </CInstruction>

  <CInstruction>
    <name>set less than unsigned</name>
    <assembler>sltu</assembler>
    <example>sltu rd, rs, rt</example>
    <meaning>if rs&lt;rt: rd=1 else= rd=0</meaning>
    <format>R</format>
    <opcode>0</opcode>
    <function>43</function>
    <regWrite>true</regWrite>
    <regDestination>rd</regDestination>
    <regFileInput>aluLO</regFileInput>
    <aluSource>regFile</aluSource>
    <aluControl>setLessThanU</aluControl>
    <memWrite>false</memWrite>
    <memRead>false</memRead>
    <memWordSize>singleByte</memWordSize>
    <pcSource>programCounter</pcSource>
    <systemcall>false</systemcall>
  </CInstruction>

  <!-- I INSTRUCTIONS -->
  <CInstruction>
    <name>branch on less than zero</name>
    <assembler>bltz</assembler>
    <example>bltz rs, imm</example>
    <meaning>if rs&lt;0: pc += imm * 4 + 4</meaning>
    <format>I</format>
    <opcode>1</opcode>
    <function>0</function>
    <regWrite>false</regWrite>
    <regDestination>rt</regDestination>
    <regFileInput>aluLO</regFileInput>
    <aluSource>regFile</aluSource>
    <aluControl>setLessThanZero</aluControl>
    <memWrite>false</memWrite>
    <memRead>false</memRead>
    <memWordSize>singleByte</memWordSize>
    <pcSource>signExtendLessThanZero</pcSource>
    <systemcall>false</systemcall>
  </CInstruction>
    
  <CInstruction>
    <name>branch on equal</name>
    <assembler>beq</assembler>
    <example>beq rs, rt, imm</example>
    <meaning>if rs==rt: pc += imm * 4 + 4</meaning>
    <format>I</format>
    <opcode>4</opcode>
    <function>0</function>
    <regWrite>false</regWrite>
    <regDestination>rt</regDestination>
    <regFileInput>aluLO</regFileInput>
    <aluSource>regFile</aluSource>
    <aluControl>sub</aluControl>
    <memWrite>false</memWrite>
    <memRead>false</memRead>
    <memWordSize>singleByte</memWordSize>
    <pcSource>signExtendEqual</pcSource>
    <systemcall>false</systemcall>
  </CInstruction>

  <CInstruction>
    <name>branch on not equal</name>
    <assembler>beq</assembler>
    <example>beq rs, rt, imm</example>
    <meaning>if rs!=rt: pc += imm * 4 + 4</meaning>
    <format>I</format>
    <opcode>5</opcode>
    <function>0</function>
    <regWrite>false</regWrite>
    <regDestination>rt</regDestination>
    <regFileInput>aluLO</regFileInput>
    <aluSource>regFile</aluSource>
    <aluControl>sub</aluControl>
    <memWrite>false</memWrite>
    <memRead>false</memRead>
    <memWordSize>singleByte</memWordSize>
    <pcSource>signExtendUnequal</pcSource>
    <systemcall>false</systemcall>
  </CInstruction>

  <CInstruction>
    <name>branch on less than or equal to zero</name>
    <assembler>blez</assembler>
    <example>beq rs, rt, imm</example>
    <meaning>if rs&lt;=rt: pc += imm * 4 + 4</meaning>
    <format>I</format>
    <opcode>6</opcode>
    <function>0</function>
    <regWrite>false</regWrite>
    <regDestination>rt</regDestination>
    <regFileInput>aluLO</regFileInput>
    <aluSource>regFile</aluSource>
    <aluControl>setLessThan</aluControl>
    <memWrite>false</memWrite>
    <memRead>false</memRead>
    <memWordSize>singleByte</memWordSize>
    <pcSource>signExtendLessOrEqualZero</pcSource>
    <systemcall>false</systemcall>
  </CInstruction>

  <CInstruction>
    <name>addition imm. unsigned</name>
    <assembler>addi</assembler>
    <example>addi rt, rs, imm</example>
    <meaning>rt = rs + imm</meaning>
    <format>I</format>
    <opcode>8</opcode>
    <function>0</function>
    <regWrite>true</regWrite>
    <regDestination>rt</regDestination>
    <regFileInput>aluLO</regFileInput>
    <aluSource>signExtend</aluSource>
    <aluControl>add</aluControl>
    <memWrite>false</memWrite>
    <memRead>false</memRead>
    <memWordSize>singleByte</memWordSize>
    <pcSource>programCounter</pcSource>
    <systemcall>false</systemcall>
  </CInstruction>

  <CInstruction>
    <name>addition imm. unsigned</name>
    <assembler>addiu</assembler>
    <example>addiu rt, rs, imm</example>
    <meaning>rt = rs + imm</meaning>
    <format>I</format>
    <opcode>9</opcode>
    <function>0</function>
    <regWrite>true</regWrite>
    <regDestination>rt</regDestination>
    <regFileInput>aluLO</regFileInput>
    <aluSource>signExtend</aluSource>
    <aluControl>addu</aluControl>
    <memWrite>false</memWrite>
    <memRead>false</memRead>
    <memWordSize>singleByte</memWordSize>
    <pcSource>programCounter</pcSource>
    <systemcall>false</systemcall>
  </CInstruction>

  <CInstruction>
    <name>set less than imm.</name>
    <assembler>slti</assembler>
    <example>slti rt, rs, imm</example>
    <meaning>if rs&lt;imm: rt=1 else rt=0</meaning>
    <format>I</format>
    <opcode>10</opcode>
    <function>0</function>
    <regWrite>true</regWrite>
    <regDestination>rt</regDestination>
    <regFileInput>aluLO</regFileInput>
    <aluSource>signExtend</aluSource>
    <aluControl>setLessThan</aluControl>
    <memWrite>false</memWrite>
    <memRead>false</memRead>
    <memWordSize>singleByte</memWordSize>
    <pcSource>programCounter</pcSource>
    <systemcall>false</systemcall>
  </CInstruction>

  <CInstruction>
    <name>set less than imm. unsigned</name>
    <assembler>sltiu</assembler>
    <example>sltiu rt, rs, imm</example>
    <meaning>if rs&lt;imm: rt=1 else rt=0</meaning>
    <format>I</format>
    <opcode>11</opcode>
    <function>0</function>
    <regWrite>true</regWrite>
    <regDestination>rt</regDestination>
    <regFileInput>aluLO</regFileInput>
    <aluSource>signExtend</aluSource>
    <aluControl>setLessThanU</aluControl>
    <memWrite>false</memWrite>
    <memRead>false</memRead>
    <memWordSize>singleByte</memWordSize>
    <pcSource>programCounter</pcSource>
    <systemcall>false</systemcall>
  </CInstruction>

  <CInstruction>
    <name>or imm.</name>
    <assembler>ori</assembler>
    <example>ori rt, rs, imm</example>
    <meaning>rt = rs or imm</meaning>
    <format>I</format>
    <opcode>13</opcode>
    <function>0</function>
    <regWrite>true</regWrite>
    <regDestination>rt</regDestination>
    <regFileInput>aluLO</regFileInput>
    <aluSource>signExtend</aluSource>
    <aluControl>or</aluControl>
    <memWrite>false</memWrite>
    <memRead>false</memRead>
    <memWordSize>singleByte</memWordSize>
    <pcSource>programCounter</pcSource>
    <systemcall>false</systemcall>
  </CInstruction>

  <CInstruction>
    <name>xor imm.</name>
    <assembler>xori</assembler>
    <example>xori rt, rs, imm</example>
    <meaning>rt = rs xor imm</meaning>
    <format>I</format>
    <opcode>14</opcode>
    <function>0</function>
    <regWrite>true</regWrite>
    <regDestination>rt</regDestination>
    <regFileInput>aluLO</regFileInput>
    <aluSource>signExtend</aluSource>
    <aluControl>xor</aluControl>
    <memWrite>false</memWrite>
    <memRead>false</memRead>
    <memWordSize>singleByte</memWordSize>
    <pcSource>programCounter</pcSource>
    <systemcall>false</systemcall>
  </CInstruction>
  
  <CInstruction>
    <name>load upper immediate</name>
    <assembler>lui</assembler>
    <example>lui register, imm</example>
    <meaning>register = imm &lt;&lt; 16</meaning>
    <format>I</format>
    <opcode>15</opcode>
    <function>0</function>
    <regWrite>true</regWrite>
    <regDestination>rt</regDestination>
    <regFileInput>aluLO</regFileInput>
    <aluSource>signExtend</aluSource>
    <aluControl>shiftLeft16</aluControl>
    <memWrite>false</memWrite>
    <memRead>false</memRead>
    <memWordSize>singleByte</memWordSize>
    <pcSource>programCounter</pcSource>
    <systemcall>false</systemcall>
  </CInstruction>

  <CInstruction>
    <name>load byte</name>
    <assembler>lb</assembler>
    <example>lb rt, imm(rs)</example>
    <meaning>rt = Mem[rs + imm]</meaning>
    <format>I</format>
    <opcode>32</opcode>
    <function>0</function>
    <regWrite>true</regWrite>
    <regDestination>rt</regDestination>
    <regFileInput>dataMemory</regFileInput>
    <aluSource>signExtend</aluSource>
    <aluControl>add</aluControl>
    <memWrite>false</memWrite>
    <memRead>true</memRead>
    <memWordSize>singleByte</memWordSize>
    <pcSource>programCounter</pcSource>
    <systemcall>false</systemcall>
  </CInstruction>

  <CInstruction>
    <name>load half word</name>
    <assembler>lh</assembler>
    <example>lh rt, imm(rs)</example>
    <meaning>rt = Mem[rs + imm]</meaning>
    <format>I</format>
    <opcode>33</opcode>
    <function>0</function>
    <regWrite>true</regWrite>
    <regDestination>rt</regDestination>
    <regFileInput>dataMemory</regFileInput>
    <aluSource>signExtend</aluSource>
    <aluControl>add</aluControl>
    <memWrite>false</memWrite>
    <memRead>true</memRead>
    <memWordSize>halfWord</memWordSize>
    <pcSource>programCounter</pcSource>
    <systemcall>false</systemcall>
  </CInstruction>

  <CInstruction>
    <name>load word</name>
    <assembler>lw</assembler>
    <example>lw rt, imm(rs)</example>
    <meaning>rt = Mem[rs + imm]</meaning>
    <format>I</format>
    <opcode>35</opcode>
    <function>0</function>
    <regWrite>true</regWrite>
    <regDestination>rt</regDestination>
    <regFileInput>dataMemory</regFileInput>
    <aluSource>signExtend</aluSource>
    <aluControl>add</aluControl>
    <memWrite>false</memWrite>
    <memRead>true</memRead>
    <memWordSize>word</memWordSize>
    <pcSource>programCounter</pcSource>
    <systemcall>false</systemcall>
  </CInstruction>

  <CInstruction>
    <name>load byte unsigned</name>
    <assembler>lbu</assembler>
    <example>lbu rt, imm(rs)</example>
    <meaning>rt = Mem[rs + imm]</meaning>
    <format>I</format>
    <opcode>36</opcode>
    <function>0</function>
    <regWrite>true</regWrite>
    <regDestination>rt</regDestination>
    <regFileInput>dataMemory</regFileInput>
    <aluSource>signExtend</aluSource>
    <aluControl>addu</aluControl>
    <memWrite>false</memWrite>
    <memRead>true</memRead>
    <memWordSize>singleByte</memWordSize>
    <pcSource>programCounter</pcSource>
    <systemcall>false</systemcall>
  </CInstruction>

  <CInstruction>
    <name>load half word unsigned</name>
    <assembler>lhu</assembler>
    <example>lhu rt, imm(rs)</example>
    <meaning>rt = Mem[rs + imm]</meaning>
    <format>I</format>
    <opcode>37</opcode>
    <function>0</function>
    <regWrite>true</regWrite>
    <regDestination>rt</regDestination>
    <regFileInput>dataMemory</regFileInput>
    <aluSource>signExtend</aluSource>
    <aluControl>addu</aluControl>
    <memWrite>false</memWrite>
    <memRead>true</memRead>
    <memWordSize>halfWord</memWordSize>
    <pcSource>programCounter</pcSource>
    <systemcall>false</systemcall>
  </CInstruction>

  <CInstruction>
    <name>store byte</name>
    <assembler>sb</assembler>
    <example>sb rt, imm(rs)</example>
    <meaning>Mem[rs + imm] = rt</meaning>
    <format>I</format>
    <opcode>40</opcode>
    <function>0</function>
    <regWrite>false</regWrite>
    <regDestination>rt</regDestination>
    <regFileInput>aluLO</regFileInput>
    <aluSource>signExtend</aluSource>
    <aluControl>add</aluControl>
    <memWrite>true</memWrite>
    <memRead>false</memRead>
    <memWordSize>singleByte</memWordSize>
    <pcSource>programCounter</pcSource>
    <systemcall>false</systemcall>
  </CInstruction>

  <CInstruction>
    <name>store half word</name>
    <assembler>sh</assembler>
    <example>sh rt, imm(rs)</example>
    <meaning>Mem[rs + imm] = rt</meaning>
    <format>I</format>
    <opcode>41</opcode>
    <function>0</function>
    <regWrite>false</regWrite>
    <regDestination>rt</regDestination>
    <regFileInput>aluLO</regFileInput>
    <aluSource>signExtend</aluSource>
    <aluControl>add</aluControl>
    <memWrite>true</memWrite>
    <memRead>false</memRead>
    <memWordSize>halfWord</memWordSize>
    <pcSource>programCounter</pcSource>
    <systemcall>false</systemcall>
  </CInstruction>

  <CInstruction>
    <name>store word</name>
    <assembler>sw</assembler>
    <example>sw rt, imm(rs)</example>
    <meaning>Mem[rs + imm] = rt</meaning>
    <format>I</format>
    <opcode>43</opcode>
    <function>0</function>
    <regWrite>false</regWrite>
    <regDestination>rt</regDestination>
    <regFileInput>aluLO</regFileInput>
    <aluSource>signExtend</aluSource>
    <aluControl>add</aluControl>
    <memWrite>true</memWrite>
    <memRead>false</memRead>
    <memWordSize>word</memWordSize>
    <pcSource>programCounter</pcSource>
    <systemcall>false</systemcall>
  </CInstruction>

  <!-- J INSTRUCTIONS -->
  <CInstruction>
    <name>jump</name>
    <assembler>j</assembler>
    <example>j addr</example>
    <meaning>pc = addr * 4</meaning>
    <format>J</format>
    <opcode>2</opcode>
    <function>0</function>
    <regWrite>false</regWrite>
    <regDestination>ra</regDestination>
    <regFileInput>programCounter</regFileInput>
    <aluSource>regFile</aluSource>
    <aluControl>stall</aluControl>
    <memWrite>false</memWrite>
    <memRead>false</memRead>
    <memWordSize>singleByte</memWordSize>
    <pcSource>jump</pcSource>
    <systemcall>false</systemcall>
  </CInstruction>

  <CInstruction>
    <name>jump and link</name>
    <assembler>jal</assembler>
    <example>jal addr</example>
    <meaning>ra = pc + 4; pc = addr * 4</meaning>
    <format>J</format>
    <opcode>3</opcode>
    <function>0</function>
    <regWrite>true</regWrite>
    <regDestination>ra</regDestination>
    <regFileInput>programCounter</regFileInput>
    <aluSource>regFile</aluSource>
    <aluControl>stall</aluControl>
    <memWrite>false</memWrite>
    <memRead>false</memRead>
    <memWordSize>singleByte</memWordSize>
    <pcSource>jump</pcSource>
    <systemcall>false</systemcall>
  </CInstruction>
</CInstructionSet>